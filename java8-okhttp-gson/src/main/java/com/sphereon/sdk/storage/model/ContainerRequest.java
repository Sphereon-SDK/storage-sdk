/*
 * Storage
 * Sphereon Storage API provides an abstraction layer for storage of (virtual) folders and streams (files/contents) fully agnostic with respect to supported storage backends. This allows for easy uniform access to and manipulation of contents regardless of the content backend being used. Currently the following backends are supported: Sphereon Cloud Storage, Amazon S3, Azure Blob Storage, Google Cloud Storage or one of the Xillio supported content repositories like Documentum, Dropbox etc. For more information about this API please visit https://docs.sphereon.com/api/storage/0.8/
 *
 * OpenAPI spec version: 0.8
 * Contact: dev@sphereon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.sphereon.sdk.storage.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * ContainerRequest
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2019-03-06T13:57:30.609+01:00")
public class ContainerRequest {
  /**
   * The way a container is creation. If propagation is no a new container will be created in the backend; If propagation is require a existing container is used from the backend. If propagation is allowed the a new container is created if the container does not exists.
   */
  @JsonAdapter(PropagationTypeEnum.Adapter.class)
  public enum PropagationTypeEnum {
    NO("NO"),
    
    REQUIRE("REQUIRE"),
    
    ALLOW("ALLOW");

    private String value;

    PropagationTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PropagationTypeEnum fromValue(String text) {
      for (PropagationTypeEnum b : PropagationTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<PropagationTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PropagationTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PropagationTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return PropagationTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("propagationType")
  private PropagationTypeEnum propagationType = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("backendId")
  private String backendId = null;

  @SerializedName("description")
  private String description = null;

  public ContainerRequest propagationType(PropagationTypeEnum propagationType) {
    this.propagationType = propagationType;
    return this;
  }

   /**
   * The way a container is creation. If propagation is no a new container will be created in the backend; If propagation is require a existing container is used from the backend. If propagation is allowed the a new container is created if the container does not exists.
   * @return propagationType
  **/
  @ApiModelProperty(value = "The way a container is creation. If propagation is no a new container will be created in the backend; If propagation is require a existing container is used from the backend. If propagation is allowed the a new container is created if the container does not exists.")
  public PropagationTypeEnum getPropagationType() {
    return propagationType;
  }

  public void setPropagationType(PropagationTypeEnum propagationType) {
    this.propagationType = propagationType;
  }

  public ContainerRequest name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Get name
   * @return name
  **/
  @ApiModelProperty(value = "")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public ContainerRequest backendId(String backendId) {
    this.backendId = backendId;
    return this;
  }

   /**
   * The backend in which the container will be stored or is stored.
   * @return backendId
  **/
  @ApiModelProperty(value = "The backend in which the container will be stored or is stored.")
  public String getBackendId() {
    return backendId;
  }

  public void setBackendId(String backendId) {
    this.backendId = backendId;
  }

  public ContainerRequest description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Get description
   * @return description
  **/
  @ApiModelProperty(value = "")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ContainerRequest containerRequest = (ContainerRequest) o;
    return Objects.equals(this.propagationType, containerRequest.propagationType) &&
        Objects.equals(this.name, containerRequest.name) &&
        Objects.equals(this.backendId, containerRequest.backendId) &&
        Objects.equals(this.description, containerRequest.description);
  }

  @Override
  public int hashCode() {
    return Objects.hash(propagationType, name, backendId, description);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ContainerRequest {\n");
    
    sb.append("    propagationType: ").append(toIndentedString(propagationType)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    backendId: ").append(toIndentedString(backendId)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
  
}

