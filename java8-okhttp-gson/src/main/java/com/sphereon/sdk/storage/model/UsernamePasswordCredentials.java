/*
 * Storage
 * Sphereon Storage API provides an abstraction layer for storage of (virtual) folders and streams (files/contents) fully agnostic with respect to supported storage backends. This allows for easy uniform access to and manipulation of contents regardless of the content backend being used. Currently the following backends are supported: Sphereon Cloud Storage, Amazon S3, Azure Blob Storage, Google Cloud Storage or one of the Xillio supported content repositories like Documentum, Dropbox etc. For more information about this API please visit https://docs.sphereon.com/api/storage/0.8/
 *
 * OpenAPI spec version: 0.8
 * Contact: dev@sphereon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.sphereon.sdk.storage.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * UsernamePasswordCredentials
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2019-03-06T13:57:30.609+01:00")
public class UsernamePasswordCredentials {
  /**
   * Gets or Sets credentialType
   */
  @JsonAdapter(CredentialTypeEnum.Adapter.class)
  public enum CredentialTypeEnum {
    NOCREDENTIALS("NoCredentials"),
    
    OAUTHCREDENTIALS("OAuthCredentials"),
    
    BEARERTOKENCREDENTIALS("BearerTokenCredentials"),
    
    USERNAMEPASSWORDCREDENTIALS("UsernamePasswordCredentials"),
    
    OAUTH2CLIENTCREDENTIALS("OAuth2ClientCredentials");

    private String value;

    CredentialTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CredentialTypeEnum fromValue(String text) {
      for (CredentialTypeEnum b : CredentialTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<CredentialTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CredentialTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CredentialTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CredentialTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("credentialType")
  private CredentialTypeEnum credentialType = null;

  @SerializedName("password")
  private String password = null;

  @SerializedName("domain")
  private String domain = null;

  @SerializedName("userName")
  private String userName = null;

  public UsernamePasswordCredentials credentialType(CredentialTypeEnum credentialType) {
    this.credentialType = credentialType;
    return this;
  }

   /**
   * Get credentialType
   * @return credentialType
  **/
  @ApiModelProperty(value = "")
  public CredentialTypeEnum getCredentialType() {
    return credentialType;
  }

  public void setCredentialType(CredentialTypeEnum credentialType) {
    this.credentialType = credentialType;
  }

  public UsernamePasswordCredentials password(String password) {
    this.password = password;
    return this;
  }

   /**
   * The password associated with the username.
   * @return password
  **/
  @ApiModelProperty(value = "The password associated with the username.")
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  public UsernamePasswordCredentials domain(String domain) {
    this.domain = domain;
    return this;
  }

   /**
   * The domain associated with the username.
   * @return domain
  **/
  @ApiModelProperty(value = "The domain associated with the username.")
  public String getDomain() {
    return domain;
  }

  public void setDomain(String domain) {
    this.domain = domain;
  }

  public UsernamePasswordCredentials userName(String userName) {
    this.userName = userName;
    return this;
  }

   /**
   * The username.
   * @return userName
  **/
  @ApiModelProperty(value = "The username.")
  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UsernamePasswordCredentials usernamePasswordCredentials = (UsernamePasswordCredentials) o;
    return Objects.equals(this.credentialType, usernamePasswordCredentials.credentialType) &&
        Objects.equals(this.password, usernamePasswordCredentials.password) &&
        Objects.equals(this.domain, usernamePasswordCredentials.domain) &&
        Objects.equals(this.userName, usernamePasswordCredentials.userName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(credentialType, password, domain, userName);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UsernamePasswordCredentials {\n");
    
    sb.append("    credentialType: ").append(toIndentedString(credentialType)).append("\n");
    sb.append("    password: ").append(toIndentedString(password)).append("\n");
    sb.append("    domain: ").append(toIndentedString(domain)).append("\n");
    sb.append("    userName: ").append(toIndentedString(userName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
  
}

